# evasion-framework

Testing IOCTL's in Android device drivers without devices.

Project description
 * Evasion kernel
 * DTB rewriter
 * Binary patcher
 * Emulator
 * Symoblic executor

The core of the evasion framework are evasion kernels.

# Dependencies
## Download cross compilers and Qemu 3.1.1

You will need ARM cross compilers to compile the evasion kernels. You will aslo need to have Qemu 3.10 to emulate the kernels. You can use script `setup.sh` to fetch compilers from codeaurora into 'compilers' folder and Qemu into 'qemu-3.1.1' folder

```
$ ./setup.sh
```

# Example/Tutorial

Evasion framework is a complex project that includes many parts. One way to understand what each part does is to demostrate how they are used with an example. We will rediscover a vulnerability in Xiaomi REDMI6 kernel.
The first step is to checkout the xioami kernel and the commit with the vulnerability.

```
$ cd examples
$ git clone https://github.com/MiCode/Xiaomi_Kernel_OpenSource.git 
$ git checkout cactus-p-oss
$ git ee99fdb82cdafe8cd16dd516b9944e222f6db7e2
```

## Vulnerability description
Here is the description of the vulnrability:
ZERO_SIZE_PTR dereference in ./drivers/misc/mediatek/cameraisp/src/mt6765/camera_isp.c (https://github.com/MiCode/Xiaomi_Kernel_OpenSource.git.

A local application can issue ISP_WRITE_REGISTER ioctl and cause a ZERO_SIZE_PTR (equals 0x10) dereference due to that the
return value of kmalloc(0) is checked against NULL but not against ZERO_SIZE_PTR.

Vulnerabl code in ISP_WriteReg() (around line 4383):

```
// Around line 4383
static signed int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
{
        ...
    pData = kmalloc((pRegIo->Count) * sizeof(struct ISP_REG_STRUCT), // <--- pRegIo->Count is user-provided and can be zero, and kmalloc(0) returns ZERO_SIZE_PTR = 0x10
            GFP_ATOMIC);
    if (pData == NULL) {            // <--- pData is 0x10, so this check passes
            ...
        goto EXIT;
    }
    ...

    Ret = ISP_WriteRegToHw(         // Now we go inside ISP_WriteRegToHw() with pData set to ZERO_SIZE_PTR = 0x10
              pData,
              pRegIo->Count);
...
...

// Around line 4287
static signed int ISP_WriteRegToHw(
    struct ISP_REG_STRUCT *pReg,    // pReg is ZERO_SIZE_PTR = 0x10
    unsigned int         Count)
{
        ...
    module = pReg->module;          // finally, pReg=0x10 is dereferenced

...
```
In more detail, when a userspace program calls ISP_WRITE_REGISTER ioctl, it can set pRegIo->Count to 0. kmalloc() is thus called with zero size which returns ZERO_SIZE_PTR = 0x10 (https://lwn.net/Articles/236809/). The driver however only checks if the return value is NULL (i.e. the case the kernel is out of memory), but does not check for ZERO_SIZE_PTR. The driver continues execution and calls ISP_WriteRegToHw(pData,...). Inside function ISP_WriteRegToHw(), pReg=ZERO_SIZE_PTR is dereferences (line module = pReg->module;).


## Building Xiaomi kernel

If you see the following error during the complication:
`/usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x50): multiple definition of ``yylloc'; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here`,
replace definition of `YYLTYPE yylloc;` with `extern YYLTYPE yylloc;`

Also some of the pythong scripts might expect python2, if you use python3 by default, fix this by replacing `#! /usr/bin/python` with `#! /usr/bin/python2` in failing scripts.

```
export PATH="$PATH:$(realpath ../../compilers/arm-linux-androideabi-4.9/bin)"
make ARCH=arm CROSS_COMPILE=arm-linux-androideabi- cactus_defconfig
make ARCH=arm CROSS_COMPILE=arm-linux-androideabi- -j3
```

You probably will see missing header files during compilation. This should probably be reported to the xiaomi developers. However we are not interested in compiling the xiaomi kernel actually, we just need to generated autogenerated files to be able to compile the vulnerable module. So you can safely move to the next section.

*But* if you really want to compile the xioami kernel, you can fix the errors by:
Replace drivers/devfreq/helio-dvfsrc-opp.c:14:26 
 `#include <helio-dvfsrc.h>` with `#include "helio-dvfsrc.h"`

In
 drivers/devfreq/helio-dvfsrc.h replace
 `#include <helio-dvfsrc-mt6765.h>` with `#include "helio-dvfsrc-mt6765.h"`

and so on.

## Compiling vulnerable driver
We need to compile the driver as a kernel module (.ko file).

We assume you are in xioami folder.
```
cd drivers/misc/mediatek/cameraisp/src/mt6765
```

Modify the Makefile:

Add the following lines:
```
ccflags-y += -I$(srctree)/drivers/misc/mediatek/cmdq/v3/mt6765/
obj-m += camera_isp.o

all:
                make -C ../../../../../../ M=$(PWD) ARCH=arm CROSS_COMPILE=arm-linux-androideabi- modules

		clean:
		                rm -f *.ko *.o
```

and comment out this line:
```
obj-y += camera_isp.o
```

Then run `make`. You should get `camera_isp.ko`.


## Building the evasion kernel

Now we have the driver, in order to emuluate it, we need to load it to the evasion kernel.  In order to increase the probability of successfully loading the driver, the evasion kernel needs to be as close to the driver's host kernel (in our case the MSM kernel) as much as possible. By running `make kernelversion` inside xiaomi kernel tree, we can see that it's version is `v4.9.117`. Thus we will use the evasion kernel based on vanilla kernel 4.9.117.

The evasion kernel is a modification of the Linux vanilla kernel. In order safe space, we distribute patches that will make evasion kernel from the vanilla kernel. The patches for 4.9.117 are in `evasion-kernels/patches/4.9.117/`. First download the vanilla kernel, and apply the patch and copy missing files.

```
$ cd evasion-kernels
$ wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.117.tar.xz 
$ tar -xf linux-4.9.117.tar.xz
$ mv linux-4.9.117 linux-4.9.117-evasion
$ rm linux-4.9.117.tar.xz
$ patch -d linux-4.9.117-evasion -p1 <patches/4.9.117/linux-4.9.117.alien-patch
$ cp patches/4.9.117/* linux-4.9.117-evasion
```

Now you can build the evasion kernel:
```
$ cd linux-4.9.117-evasion
$ ./configure.sh
$ ./menuconfig # <---- IMPORTANT: go to kernel hacking->tracers and enable "Support for tracing block IO actions"
$ ./make.sh
```

As a sanity check you can try to emulate the kernel by running `run-arm-kernel-4.9.sh`.


## Adjusting evasion kernel configuration

Our driver was compiled against a specific xiaomi kernel configuration. In particluar, this kernel configuration defines: (a) kernel subsystems, (b) layout of various kernel structures that are used by the driver. Drivers that implement IOCTL interface use at least the following kernel structures: `struct device` and `struct file`. It is *critical* for the evasion kernel to have the same layouts for these structures (i.e. the same fields at the same offsets). Because of this it is critical that the configuration options that appear in definitions of `struct device` and `struct file` are the same in the xiaomi and evasion kernel.

In order to verify that layouts are the same, we use a special kernel module that lists all the fields in the aforementioned structures. We compile this module against the evasion and xioami kernels and look if the layouts of these structures are different.

### Copy checkoofset module and build it

The module we are going to use is called `testoffsets.ko`, and it located in `evasion-kernels/mymodules/testoffsets`. You need to copy to and compile against both the evasion kernel and the xioami kernels.

```
$ 
$ cp -r evasion-kernels/mymodules examples/Xiaomi_Kernel_OpenSource
$ cp -r evasion-kernels/mymodules evasion-kernels/linux-4.9.117-evasion
$ make -C examples/Xiaomi_Kernel_OpenSource/mymodules/testoffsets
$ make -C evasion-kernels/linux-4.9.117-evasion/mymodules/testoffsets
```

### Compare `struct dev` and `struct file` layouts
Now we need to compare the modules.

First check offsets of `struct file`.

```
./compare-offsets.py -v evasion-kernels/linux-4.9.117-evasion/mymodules/testoffsets/testoffsets.ko -x examples/Xiaomi_Kernel_OpenSource/mymodules/checkoffsets/testoffsets.ko --file
```

It should tell you that you CONFIG_SECURITY is not set in the evasion kernel. Set it, recompile. Ater this step, the layouts of `struct device` and `struct file` should be the same.


```
./compare-offsets.py -v evasion-kernels/linux-4.9.117-evasion/mymodules/testoffsets/testoffsets.ko -x examples/Xiaomi_Kernel_OpenSource/mymodules/checkoffsets/testoffsets.ko --dev
```

It should say that there is a offset mismatch between tokens 83 87. This is bit cryptic becuase the script is not finished (contributions are welcome).  You need to look at testoffsets.c to see what configuration options are responsbile for these tokens. This is the part between these tokens:

```
261   quasi_print((uint32_t)&dev_local->pm_domain,INIT_TOKEN+83);
262   #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
263   quasi_print((uint32_t)&dev_local->msi_domain,INIT_TOKEN+84);
264   #endif
265   #ifdef PINCTRL
266   quasi_print((uint32_t)&dev_local->pins,TOKEN_RANGE1+6);
267   #endif
268   #ifdef CONFIG_GENERIC_MSI_IRQ
269   quasi_print((uint32_t)&dev_local->msi_list,INIT_TOKEN+85);
270   #endif
271   #ifdef CONFIG_NUMA
272   quasi_print((uint32_t)&dev_local->numa_node,INIT_TOKEN+86);
273   #endif
274   quasi_print((uint32_t)&dev_local->dma_mask,INIT_TOKEN+87);
```

Thus you need to check if the following config options are present/missing in both the evasion and xioami kernels. As you will find out `PINCTRL` option is set in Xiaomi kernel and is missing in the evasion kernel. Thus you need to enable this option in the evasion kernel. Relunch menuconfig, set the option and recompile the kernel and the testoffsets.ko module. This should fix the offset descripancy.


### Patching vulnerable driver

The driver we just compiled relies on some Xioami-specific functions. These function are not present in the evasion kernel. We need to tell the evasion kernel what to do with them. More specifically, we need to tell the kernel function prototypes for those functions, so that the evasion kernel can choose the right stub.

First ru this inside the xiaomi kernel tree:
```
ctags -R --fields=+KmnSpt --c-kinds=f .
```

Next go to `evasion-framework/fuzzer/patcher`.
and run the following command
1. Install necessary perl modules.
```
sudo cpan Binutils::Objdump
sudo cpan Parse::ExuberantCTags
```
2. Run the script to extract function prototypes.
```
./funcsigs.pl ../../examples/Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/cameraisp/src/mt6765/camera_isp.ko ../../examples/Xiaomi_Kernel_OpenSource/tags
```

Function prototypes will be extracted to inject/inject.c. Now we need to compile it and link with out module.

```
cd inject/
export PATH="$PATH:$(realpath ../../../compilers/arm-eabi-4.8/bin/)"
make
arm-eabi-ld -r inject.o ../../../examples/Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/cameraisp/src/mt6765/camera_isp.ko -o camera_isp-injected.ko
```
You should get file `camera_isp-injected.ko` which now contains an additional ELF section `protos` that has the function signatures.
















Now we have the driver. In order to execute it, we need to load it into a kernel. The original msm kernel won't run inside Qemu due to hardware dependencies that Qemu does not have (see our paper for details). Vanilla Linux kernel is not going to work either because the driver depends on msm kernel. Also the driver expects the peripheral it controls to be present (and Qemu does not have it). 

This is where our evasion kernel comes into play. It resolves all the dependencies in a generic way.






### Configure evasion kernel 

Our driver was compiled against a specific kernel configuration. In particluar, kernel configuration defines: (a) kernel subsystems, (b) layout of various kernel structures that are used by the driver. Drivers that implement IOCTL interface use at least the following kernel structures: `struct device` and `struct file`. It is critical for the evasion kernel to have the same layout for these structures. In order to help with this, 


Because of this it is critical that the evasion kernel has some of the configuraiton options identical to the driver's host kernel.

It is very important that the evasion kernel has the same configuration option for 

to configure the evasion kernel the same way.

```
$ cd evasion-kernels/linux-3.10-alien
$ ./configure.sh
$ ./make.sh
```



### Patching device tree file
The driver expects a specific peripheral to be present. We don't emulate the device. Instead we make the kernel and the driver believe that the peripheral is persent. In order to do that we add a device tree entry to the devce tree file. The first step is to identify the device tree entry name. In order to find the name of the device tree nodes expected by the driver you can grep `compatible` property.

```
grep "compatible = " evasion-framework/examples/Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/cameraisp/src/mt6765/*
```

This shoud give you the following list:

```
 { .compatible = "mediatek,imgsys", },
 { .compatible = "mediatek,dip1", },
 { .compatible = "mediatek,camsys", },
 { .compatible = "mediatek,cam1", },
 { .compatible = "mediatek,cam2", },
 { .compatible = "mediatek,cam3", },
 { .compatible = "mediatek,camsv0", },
 { .compatible = "mediatek,camsv1", },
 { .compatible = "mediatek,camsv2", },
 { .compatible = "mediatek,camsv3", },
 { .compatible = "mediatek,camsv4", },
 { .compatible = "mediatek,camsv5", },
 /*{ .compatible = "mediatek,camsv6", },
```

When we compiled the xiaomi kernel, it also compiled some of the device tree files. They can be found in `arch/arm/boot/dts/`. One of them is arch/arm/boot/dts/mt6765.dtb. Let's see if it contains our entries:
```
$ grep mediatek,imgsys  arch/arm/boot/dts/mt6756.dtb
Binary file arch/arm/boot/dts/mt6765 matches
```
It contains the first device tree node. We need to copy it to the evasion kernel's device tree file. You can use `evasion-framework/fuzzer/fdt-extract/fdtextract` program to do this:

```
$ ./fdtextract -f /home/ivan/prj/evasion-framework/examples/Xiaomi_Kernel_OpenSource/arch/arm/boot/dts/mt6765.dtb -t /home/ivan/prj/evasion-framework/evasion-kernels/linux-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb "mediatek,imgsys"
Going to extract node 'mediatek,imgsys'
from file: '/home/ivan/prj/evasion-framework/examples/Xiaomi_Kernel_OpenSource/arch/arm/boot/dts/mt6765.dtb' and inject it
into file: '/home/ivan/prj/evasion-framework/evasion-kernels/linux-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb'

[+] Loading dtb's: '/home/ivan/prj/evasion-framework/examples/Xiaomi_Kernel_OpenSource/arch/arm/boot/dts/mt6765.dtb', '/home/ivan/prj/evasion-framework/evasion-kernels/linux-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb'
[+] Found node 'imgsys@15020000' (compatible = 'mediatek,imgsys') in the host dtb
[+] Analyzing node
    Found #interrupt-cells in node intpol-controller@10200a80
    interrupt cells = 3
    Looking for node's parent in host dtb
    After checking the parent: the node is NOT an i2c device.
[+] Preparing new empty node under root in evasion dtb
[+] Copying host node's properties into the prepared empty node
    + copying property compatible, len = 23
    + copying property reg, len = 16
    + copying property #clock-cells, len = 4
    + copying property clocks, len = 80
    + copying property clock-names, len = 154
    - skipping 'linux,phandle' property
    = replacing 'phandle' property with a newly generated value
[+] Backing up evasion dtb into 'backup.dtb'
[+] Rewriting the original evasion dtb file
```

Now repeat the same for nodes 

```
mediatek,dip1 
mediatek,camsys
mediatek,cam1,
mediatek,cam2,
mediatek,cam3,
mediatek,camsv1
mediatek,camsv2
mediatek,camsv3
mediatek,camsv4
mediatek,smi_larb0
mediatek,smi_larb1
mediatek,smi_larb2
mediatek,smi_larb3
mediatek,seninf1
mediatek,seninf2
mediatek,seninf3
mediatek,seninf4
mediatek,apmixed
mediatek,mmsys_config
```

There are no entries in xioami dtb for nodes
```
mediatek,camsv0
mediatek,camsv5
mediatek,smi_larb4
mediatek,smi_larb5
mediatek,smi_larb6
mediatek,smi_larb7
```

In this case we will create generic nodes using the same program (`fdtextract`):
```
$ ./fdtextract -f none -t /home/ivan/prj/evasion-framework/evasion-kernels/linux
-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb "mediatek,camsv0"
[+] Going to create a new node 'mediatek,camsv0' in file '/home/ivan/prj/evasion-framework/evasion-kernels/linux-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb'
[+] Loading dtb: '/home/ivan/prj/evasion-framework/evasion-kernels/linux-4.9.117-alien/arch/arm/boot/dts/vexpress-v2p-ca15-tc1.dtb'
[+] Preparing new empty node 'generic_node_94068169@4ba00000' under root in evasion dtb
[+] Adding new fields
[+] Adding dummy subnode 'generic_subnode_1137472617'
[+] Backing up evasion dtb into 'backup.dtb'
[+] Rewriting the original evasion dtb file
```
(repeat for other nodes).


### Loading the driver inside the evasion kernel
Now we should be ready to load our driver inside the evasion kernel.

```
cd evasion-kernels/linux-4.9.117-alien
run-arm-kernel-4.9.sh
# Go to the inject folder with the patched module
scp camera_isp-injected.ko root@192.168.99.36:
```

In the evasion kernel in Qemu:
```
# insmod camera_isp-injected.ko
# lsmod
Module                  Size  Used by    Tainted: G
camera_isp            395594  0 [permanent]
```

and you should also have a new entry in `/dev/` : `/dev/camera-isp`.

At this point we verfied that we can load the driver and it creates  a dev entry for which we can issue ioctl's

# Part 2: fuzzing

Now we have the configured evasion kernel and the driver.

